package whiler.gotop;

import org.objectweb.asm.*;
import java.math.BigInteger;
import java.util.Map;
import java.util.TreeMap;

/**
 * A Compiler for compiling Goto Programs into Java Bytecode using the ASM
 * library.
 */
public class CompileJava implements Opcodes {
	Program prog;
	/**
	 * The MethodVisitor is generated by ASM's ClassWriter. Calling the
	 * visit*Insn methods in it generates the appropriate bytecode instructions.
	 */
	MethodVisitor mv;
	/**
	 * Array of bytecode labels. There is one label per Goto instruction, so
	 * jumping to label "i" results in a jump to goto instruction "i".
	 */
	Label [] labels;
	/**
	 * The internal class name using slashes
	 */
	String className;
	/**
	 * The external class name using dots
	 */
	String classNameOrig;
	/**
	 * Map of all constants used by instructions.
	 * 
	 * The map key is the constant value, and the value the map value is the
	 * index of the constant. The constant will be generated as a "private
	 * static final" field named const_"index".
	 */
	Map<BigInteger, Integer> constants;
	
	private CompileJava (String className, Program prog) {
		this.prog = prog;
		this.className = className.replace ('.', '/');
		classNameOrig = className;
		constants = new TreeMap<BigInteger, Integer> ();
		
		// Collect all constants
		for (int i = 0; i < prog.op.length; i++) {
			// Only assignments contain constants (offset)
			if (prog.op [i] instanceof Assign) {
				Assign a = (Assign) prog.op [i];
				// Don't add twice
				if (!constants.containsKey (a.add)) {
					constants.put (a.add, constants.size ());
				}
			}
		}
	}
	/**
	 * Perform the compilation.
	 * @return	Generated .class file contents
	 */
	private JavaProg doRun () throws Exception {
		// The ClassWriter visitor generates class files when the .visit* methods are called.
		ClassWriter cw = new ClassWriter (ClassWriter.COMPUTE_FRAMES);
		FieldVisitor fv;
		
		// Generate class
		cw.visit (V1_8, ACC_PUBLIC + ACC_SUPER, className, null, "java/lang/Object", null);
		
		{
			// Generate fields for constants
			for (Map.Entry<BigInteger, Integer> entry : constants.entrySet ()) {
				fv = cw.visitField (ACC_PRIVATE + ACC_FINAL + ACC_STATIC, "const_" + entry.getValue ().toString (), "Ljava/math/BigInteger;", null, null);
				fv.visitEnd ();
			}
		}
		
		{
			// Generate static one-time initialization of constants
			mv = cw.visitMethod (ACC_STATIC, "<clinit>", "()V", null, null);
			mv.visitCode ();
			
			// For each constant...
			for (Map.Entry<BigInteger, Integer> entry : constants.entrySet ()) {
				byte [] binary = entry.getKey ().toByteArray ();
				
				// Make new BigInteger
				mv.visitTypeInsn (NEW, "java/math/BigInteger");
				mv.visitInsn (DUP);
				mv.visitIntInsn (SIPUSH, (short) binary.length);
				// Make binary (byte) array
				mv.visitIntInsn (NEWARRAY, T_BYTE);
				
				// Push binary representation of the BigInteger constant into array
				for (int j = 0; j < binary.length; j++) {
					mv.visitInsn (DUP);
					mv.visitInsn (ICONST_0);
					mv.visitIntInsn (BIPUSH, binary [j]);
					mv.visitInsn (BASTORE);
				}
				
				// Call BigInteger constructor, passing the byte array
				mv.visitMethodInsn (INVOKESPECIAL, "java/math/BigInteger", "<init>", "([B)V", false);
				// Store reference in field
				mv.visitFieldInsn (PUTSTATIC, className, "const_" + entry.getValue ().toString (), "Ljava/math/BigInteger;");
			}
			
			mv.visitInsn (RETURN);
			
			mv.visitMaxs (0, 0);
			mv.visitEnd ();
		}
		
		// Generate run method
		{
			/*
			 * Local Variables 0 => Input 1 => Variables
			 */
			mv = cw.visitMethod (ACC_PUBLIC + ACC_STATIC, "run", "([Ljava/math/BigInteger;)Ljava/math/BigInteger;", null, null);
			mv.visitCode ();
			
			/**
			 *  Initialization. The corresponding java code is
			 *  <pre>{@code
			 * 		BigInteger [] variables = new BigInteger [123];
			 *		variables [0] = BigInteger.ZERO;
			 *		System.arraycopy (input, 0, variables, 1, java.lang.Math.min (input.length, variables.length-1));
			 *		for (int i = input.length + 1; i < variables.length; i++)
			 *			variables [i] = BigInteger.ZERO;
			 *  }</pre>
			 */
			
			// Make variable array
			mv.visitIntInsn (BIPUSH, prog.numVars);
			mv.visitTypeInsn (ANEWARRAY, "java/math/BigInteger");
			mv.visitVarInsn (ASTORE, 1);
			mv.visitVarInsn (ALOAD, 1);
			// Initialize field 0 with ZERO
			mv.visitInsn (ICONST_0);
			mv.visitFieldInsn (GETSTATIC, "java/math/BigInteger", "ZERO", "Ljava/math/BigInteger;");
			// Copy input variables
			mv.visitInsn (AASTORE);
			mv.visitVarInsn (ALOAD, 0);
			mv.visitInsn (ICONST_0);
			mv.visitVarInsn (ALOAD, 1);
			mv.visitInsn (ICONST_1);
			mv.visitVarInsn (ALOAD, 0);
			mv.visitInsn (ARRAYLENGTH);
			mv.visitVarInsn (ALOAD, 1);
			mv.visitInsn (ARRAYLENGTH);
			mv.visitInsn (ICONST_1);
			mv.visitInsn (ISUB);
			mv.visitMethodInsn (INVOKESTATIC, "java/lang/Math", "min", "(II)I", false);
			mv.visitMethodInsn (INVOKESTATIC, "java/lang/System", "arraycopy", "(Ljava/lang/Object;ILjava/lang/Object;II)V", false);
			
			// Initialize all other variables with ZERO
			mv.visitVarInsn (ALOAD, 0);
			mv.visitInsn (ARRAYLENGTH);
			mv.visitInsn (ICONST_1);
			mv.visitInsn (IADD);
			mv.visitVarInsn (ISTORE, 2);
			Label l0 = new Label ();
			mv.visitLabel (l0);
			mv.visitFrame (Opcodes.F_APPEND, 2, new Object [] { "[Ljava/math/BigInteger;", Opcodes.INTEGER }, 0, null);
			mv.visitVarInsn (ILOAD, 2);
			mv.visitVarInsn (ALOAD, 1);
			mv.visitInsn (ARRAYLENGTH);
			Label l1 = new Label ();
			mv.visitJumpInsn (IF_ICMPGE, l1);
			mv.visitVarInsn (ALOAD, 1);
			mv.visitVarInsn (ILOAD, 2);
			mv.visitFieldInsn (GETSTATIC, "java/math/BigInteger", "ZERO", "Ljava/math/BigInteger;");
			mv.visitInsn (AASTORE);
			mv.visitIincInsn (2, 1);
			mv.visitJumpInsn (GOTO, l0);
			mv.visitLabel (l1);
			mv.visitFrame (Opcodes.F_CHOP, 1, null, 0, null);
			
			// Create labels
			labels = new Label [prog.op.length];
			for (int i = 0; i < prog.op.length; i++) {
				labels [i] = new Label ();
			}
			// Iterate all opcodes, generate bytecode
			for (int i = 0; i < prog.op.length; i++) {
				// Set label address for referencing
				mv.visitLabel (labels [i]);
				prog.op [i].compileJava (this);
			}
			
			mv.visitMaxs (0, 0);
			mv.visitEnd ();
		}
		/**
		 * Generate main method. Corresponding Java code is:
		 * 
		 * <pre>{@code
		 * 	public static void main (String [] args) {
		 *		BigInteger [] input = new BigInteger [args.length];
		 *		for (int i = 0; i < args.length; i++) {
		 *			input [i] = new BigInteger (args [i]);
		 *		}
		 *
		 *		BigInteger output = run (input);
		 *		
		 *		System.out.println (output);
		 *	}
		 *  }</pre>
		 */
		{
			mv = cw.visitMethod (ACC_PUBLIC + ACC_STATIC, "main", "([Ljava/lang/String;)V", null, null);
			mv.visitCode ();
			mv.visitVarInsn (ALOAD, 0);
			mv.visitInsn (ARRAYLENGTH);
			mv.visitTypeInsn (ANEWARRAY, "java/math/BigInteger");
			mv.visitVarInsn (ASTORE, 1);
			mv.visitInsn (ICONST_0);
			mv.visitVarInsn (ISTORE, 2);
			Label l0 = new Label ();
			mv.visitLabel (l0);
			mv.visitFrame (Opcodes.F_APPEND, 2, new Object [] { "[Ljava/math/BigInteger;", Opcodes.INTEGER }, 0, null);
			mv.visitVarInsn (ILOAD, 2);
			mv.visitVarInsn (ALOAD, 0);
			mv.visitInsn (ARRAYLENGTH);
			Label l1 = new Label ();
			mv.visitJumpInsn (IF_ICMPGE, l1);
			mv.visitVarInsn (ALOAD, 1);
			mv.visitVarInsn (ILOAD, 2);
			mv.visitTypeInsn (NEW, "java/math/BigInteger");
			mv.visitInsn (DUP);
			mv.visitVarInsn (ALOAD, 0);
			mv.visitVarInsn (ILOAD, 2);
			mv.visitInsn (AALOAD);
			mv.visitMethodInsn (INVOKESPECIAL, "java/math/BigInteger", "<init>", "(Ljava/lang/String;)V", false);
			mv.visitInsn (AASTORE);
			mv.visitIincInsn (2, 1);
			mv.visitJumpInsn (GOTO, l0);
			mv.visitLabel (l1);
			mv.visitFrame (Opcodes.F_CHOP, 1, null, 0, null);
			mv.visitVarInsn (ALOAD, 1);
			mv.visitMethodInsn (INVOKESTATIC, className, "run", "([Ljava/math/BigInteger;)Ljava/math/BigInteger;", false);
			mv.visitVarInsn (ASTORE, 2);
			mv.visitFieldInsn (GETSTATIC, "java/lang/System", "out", "Ljava/io/PrintStream;");
			mv.visitVarInsn (ALOAD, 2);
			mv.visitMethodInsn (INVOKEVIRTUAL, "java/io/PrintStream", "println", "(Ljava/lang/Object;)V", false);
			mv.visitInsn (RETURN);
			mv.visitMaxs (6, 3);
			mv.visitEnd ();
		}
		cw.visitEnd ();
		
		// Generate binary representation and return it.
		return new JavaProg (cw.toByteArray (), className, classNameOrig);
	}
	
	/**
	 * Compiles a Goto program into a Java .class file.
	 * 
	 * @param className		Name of the class to generate (using dots)
	 * @param prog			GOTO program to compile
	 * @return				The compiled JavaProg instance which contains the binary .class file contents
	 */
	public static JavaProg run (String className, Program prog) throws Exception {
		return new CompileJava (className, prog).doRun ();
	}
}
